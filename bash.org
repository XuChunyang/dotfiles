#+CATEGORY: dotfiles

* Bash                                                                 :bash:
  :PROPERTIES:
  :header-args:bash: :tangle ~/.bash_profile :comments link
  :END:

** Meta

*** TODO 学习 Bash
    变量（全局本地）、判断、控制结构、函数。

    [[https://github.com/javier-lopez/learn/tree/master/sh][learn/sh at master · javier-lopez/learn]]

*** Resources

**** Style Guides
     - [[https://google.github.io/styleguide/shell.xml][Google Shell Style Guide]]
     - [[https://github.com/bahamas10/bash-style-guide][bahamas10/bash-style-guide: A style guide for writing safe, predictable, and portable bash scripts (not sh!)]]

**** Guides
     - [[http://tldp.org/LDP/abs/html/][Advanced Bash-Scripting Guide]]
     - [[http://wiki.bash-hackers.org/start][The Bash Hackers Wiki {Bash Hackers Wiki}]]

**** Tools    
     - [[https://github.com/Bash-it/bash-it][Bash-it/bash-it: A community Bash framework.]]
     - [[https://github.com/koalaman/shellcheck][koalaman/shellcheck: ShellCheck, a static analysis tool for shell scripts]]

** ~/.bashrc vs ~/.bash_profile

   Don't use ~/.bashrc to keep configuration, use ~/.bash_profile instead.

   #+BEGIN_SRC bash :tangle ~/.bashrc :comments link
     # The variable PS1 is unset in non-interactive shells:
     # [[https://www.gnu.org/software/bash/manual/html_node/Is-this-Shell-Interactive_003f.html][Bash Reference Manual: Is this Shell Interactive?]]
     if [ -z "$PS1" ]; then
         # This shell is not interactive
         source ~/.path
     else
         # This shell is interactive
         source ~/.bash_profile
     fi
   #+END_SRC

** OS detection

   #+BEGIN_SRC bash
     function is_mac () {
         [[ "$OSTYPE" =~ ^darwin ]]
     }

     function is_gnu_linux () {
         [[ "$OSTYPE" == linux-gnu ]]
     }
   #+END_SRC

** Helper

   #+BEGIN_SRC bash
     function source_maybe () {
         local file="$1"
         [ -r "$file" ] && [ -f "$file" ] && source "$file"
     }
   #+END_SRC

** Startup

   #+BEGIN_SRC bash
     # Add `~/bin` to the `$PATH`
     export PATH="$HOME/bin:$PATH"

     # Load the shell dotfiles, and then some:
     # * ~/.path can be used to extend `$PATH`.
     # * ~/.extra can be used for other settings you don’t want to commit.
     for file in ~/.{path,bash_prompt,exports,aliases,functions,extra}; do
         source_maybe "$file"
     done
     unset file
   #+END_SRC

** ~$PATH~ in [[file:~/.path][file:~/.path]]

   Here’s an example ~~/.path~ file that adds ~/usr/local/bin~ to the ~$PATH~:
   #+BEGIN_SRC bash :tangle no
   export PATH="/usr/local/bin:$PATH"
   #+END_SRC

** Prompt

   #+BEGIN_SRC bash
     # Looks like "~$ " in $HOME ("~" is in blue)
     PS1="\[\e[34m\]\w\[\e[m\]\\$ "
   #+END_SRC

** Other Environment variables in [[file:~/.exports][file:~/.exports]]

   #+NAME: exports
   #+BEGIN_SRC bash :tangle ~/.exports :comments link :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o644)
     # Make Emacs the default editor.
     export EDITOR='emacsclient'
     export VISUAL='emacsclient'

     # Enable support of searching Chinese for Notmuch
     export XAPIAN_CJK_NGRAM=1
   #+END_SRC

** Aliases in [[file:~/.aliases][file:~/.aliases]]

   #+NAME: aliases
   #+BEGIN_SRC bash :tangle ~/.aliases :comments link :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o644)
     # Detect which `ls` flavor is in use
     if ls --color > /dev/null 2>&1; then # GNU `ls`
         colorflag="--color=auto"
         export LS_COLORS='no=00:fi=00:di=01;31:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:'
     else # macOS `ls`
         colorflag="-G"
         export LSCOLORS='BxBxhxDxfxhxhxhxhxcxcx'
     fi

     # List all files colorized in long format
     alias l="ls -lF ${colorflag}"

     # List all files colorized in long format, including dot files
     alias la="ls -laF ${colorflag}"

     # List only directories
     alias lsd="ls -lF ${colorflag} | grep --color=never '^d'"

     # Always use color output for `ls`
     alias ls="command ls ${colorflag}"

     # Enable aliases to be sudo’ed
     alias sudo='sudo '

     # Stopwatch
     alias timer='echo "Timer started. Stop with Ctrl-D." && date && time cat && date'

     # Reload the shell (i.e. invoke as a login shell)
     alias reload="exec $SHELL -l"

     # Print each PATH entry on a separate line
     alias path='echo -e ${PATH//:/\\n}'

     # Use color with Grep
     alias grep="command grep --color=auto"

     # Cat with syntax highlight
     alias e2ansi-cat="$HOME/src/e2ansi/bin/e2ansi-cat"
   #+END_SRC

** Completion

   #+BEGIN_SRC bash
     # Add tab completion for many Bash commands (MacPorts)
     if is_mac && [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then
         . /opt/local/etc/profile.d/bash_completion.sh
     elif is_gnu_linux && [ -f /usr/share/bash-completion/bash_completion ]; then
         . /usr/share/bash-completion/bash_completion
     fi
   #+END_SRC

*** Personal bash completion in [[file:~/.bash_completion][file:~/.bash_completion]]

    #+NAME: personal_bash_completion
    #+BEGIN_SRC bash :tangle ~/.bash_completion :comments link
      command -v pandoc &>/dev/null && eval "$(pandoc --bash-completion)"

      # Use a custom version: 1) enable git-ls-files 2) support the alias dotfiles
      # cp /usr/share/bash-completion/completions/git ~/.git-completion.bash
      source_maybe "~/.git-completion.bash"

      source_maybe "/Applications/Docker.app/Contents/Resources/etc/docker.bash-completion"

      _emacs ()
      {
          local cur prev opts
          COMPREPLY=()
          cur="${COMP_WORDS[COMP_CWORD]}"
          prev="${COMP_WORDS[COMP_CWORD-1]}"
          opts='--help --version -L --directory --l --load --script --daemon --debug-init -Q --reverse-video --no-desktop --no-window-system --batch --eval --funcall'

          case $prev in
              --help|--version)
                  return
                  ;;
              -L|--directory)
                  COMPREPLY=( $(compgen -d ${cur}) )
                  return
                  ;;
              -l|--load|--script)
                  COMPREPLY=( $(compgen -f ${cur}) )
                  return
                  ;;
          esac

          COMPREPLY=( $(compgen -f -W "${opts}" -- ${cur}) )
      }
      complete -F _emacs emacs

      _emacsclient ()
      {
          local cur prev opts
          COMPREPLY=()
          cur="${COMP_WORDS[COMP_CWORD]}"
          prev="${COMP_WORDS[COMP_CWORD-1]}"
          opts='
          --version
          --help
          --tty
          --create-frame
          --eval
          --no-wait
          --quiet
          --socket-name
          --server-file
          --alternate-editor
          '

          COMPREPLY=( $(compgen -f -W "${opts}" -- ${cur}) )
      }
      complete -F _emacsclient emacsclient
    #+END_SRC

** History

   The following settings of Bash history is copied from [[https://sanctum.geek.nz/arabesque/better-bash-history/][Better Bash history | Arabesque]].

   #+BEGIN_SRC bash
     # Append history instead of rewriting it
     shopt -s histappend

     # Allow a larger history file
     HISTFILESIZE=1000000
     HISTSIZE=1000000

     # Don’t store specific lines
     HISTCONTROL='ignorespace:ignoredups'
     HISTIGNORE='pwd:ls:bg:fg:history'

     # Record timestamps
     HISTTIMEFORMAT='%F %T '

     # Use one command per line
     shopt -s cmdhist

     # Store history immediately
     PROMPT_COMMAND='history -a;'
   #+END_SRC

   Select history with [[https://github.com/peco/peco][peco]] (base on [[http://qiita.com/comutt/items/f54e755f22508a6c7d78][bash/zsh のヒストリを peco で便利にする - Qiita]]):

   #+BEGIN_SRC bash
     peco-select-history () {
         declare l=$(HISTTIMEFORMAT= history | tac | peco --query "$READLINE_LINE" | cut -c 8-)
         READLINE_LINE="$l"
         READLINE_POINT=${#l}
     }

     bind -x '"\C-r": peco-select-history'
   #+END_SRC

   See also [[https://github.com/junegunn/fzf/wiki/examples#command-history][Examples · junegunn/fzf Wiki]] and [[https://github.com/peco/peco/wiki/Sample-Usage][Sample Usage · peco/peco Wiki]].

*** TODO Read [[https://sanctum.geek.nz/arabesque/better-bash-history/][Better Bash history | Arabesque]] again

** Change directory

   #+BEGIN_SRC bash
     # Enable some Bash 4 features when possible:
     # * `autocd`, e.g. `**/qux` will enter `./foo/bar/baz/qux`
     # * Recursive globbing, e.g. `echo **/*.txt`
     for option in autocd globstar; do
         shopt -s "$option" 2> /dev/null
     done
   #+END_SRC

   Setup [[https://github.com/rupa/z][rupa/z: z - jump around]]:

   #+BEGIN_SRC bash
     if is_mac; then
         file=/opt/local/etc/profile.d/z.sh
     elif is_gnu_linux; then
         file=/etc/profile.d/z.sh
     fi

     if [ -f "$file" ]; then
         source "$file"
     else
         echo "Can't source $file, install it from <https://github.com/rupa/z>"
     fi
     unset file
   #+END_SRC

** Emacs

   [[file:~/.emacs.d/misc/emacs.sh][file:~/.emacs.d/misc/emacs.sh]] includes shell functions to launch
   Emacs's functions (such as Magit and ~C-x C-f~) inside
   Shell/Terminal.

   #+BEGIN_SRC bash
     source ~/.emacs.d/misc/emacs.sh
   #+END_SRC

** iTerm2

   With [[https://www.iterm2.com/documentation-shell-integration.html][iTerm2 Shell Integration]], iTerm2 can 

   - track recent used directories
   - capture command results
   - set mark
   - view command exit status
   - view command history
   - switch profile automatically

   To install, first downlaod the script:
   #+BEGIN_SRC bash :tangle no
     curl -L https://iterm2.com/misc/bash_startup.in -o ~/.iterm2_shell_integration.bash
   #+END_SRC

   Then load it:
   #+BEGIN_SRC bash
     [ "$TERM_PROGRAM" == "iTerm.app" ] && source_maybe "$HOME/.iterm2_shell_integration.bash"
   #+END_SRC
